<!doctype html>
<html lang='en-us'>
<meta charset='utf-8'>
<meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- solves mobile issues. see http://www.javierusobiaga.com/blog/stop-using-the-viewport-tag-until-you-know-ho/ for what initial-scale does -->
<title>Interactive Text</title>
<style>
html {height: 100%;}

body {font-family: 'Open Sans', sans-serif;}

/* bold-only, non-blue links are hard to distinguish and unconventional */
a:not([href]) {color: blue;}
a[onmousedown]:not([href]) {cursor: pointer;}
a[href] {
	text-decoration: none;
	background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12"><path fill="white" stroke="%2336b" d="M1.5 4.5h6v6h-6z"/><path d="M5.5 8.5l-2-2 2.7-2.7-1.5-1.5.8-.8h5v5l-.8.79L8.2 5.8z" fill="white" stroke="%2336b"/></svg>') right center no-repeat;
	padding-right: 13px;
}

a[href]:link {color: #36b;}
a[href]:hover, a[onmousedown]:hover {text-decoration: underline;}

.disabled_link {text-decoration: line-through;}
.disabled_link:hover {text-decoration: none;}

/* surround with brackets. used to separate options */
.ca::after {content: ']';}
.ca::before {content: '[';}

/* bold links in history have an intuitive meaning. links surrounded with brackets have unclear meaning, overlapping with the keyboard shortcuts */
.chosen_link_in_history {font-weight: bold;}
/* links in history aren't clickable. the user has Pavlovian training to click on blue links, and is constantly surprised by nonclickable blue text. darkening fixes this problem */
a:not([href]).history {color: DarkBlue;}

/* hide text so that a screenreader can find it, but not visual users */
.screenreader {
	height: 1px;
	width: 1px;
	position: absolute;
	overflow: hidden;
	top: -10px;
}

p {margin-bottom: 0px}
li {margin-bottom: 0px}
</style>
{{{ SCRIPT }}}

<!-- inverse flexbox moves the options tab order to the end of the page, so that the first tab chooses a game link, instead of an options link -->
<body id='flexboxflip' style='display: flex; color:#222222; min-height: 100%; margin: 0;'>
	<!-- role='status' is for ARIA accessibility. role='main' by itself is not re-read properly. w3c validator says one role only. note that IE doesn't support the main tag. -->
	<div id=main_body role=status style='margin:0.3em; white-space:pre-wrap;' aria-live=polite>Waiting for game to load</div>

	<hr id=history_separator style='margin:1em'>
	<!-- visual testing shows that this horizontal bar is critical to helping the user find the beginning of the passage. if it's not visible, the user worries and scrolls up to make sure he didn't miss anything. -->
	<!-- we add a scrolltarget which is slightly higher than the bar, because scrollIntoView(bar) makes the bar indistinguishable from the top of the page. -->
	<!-- if the main message is too long, its top will stick to the top of the page, and the bottom of the message will take priority over the scrollback. -->
	<div id=scrolltarget style='padding-bottom:0.3em;'></div>

	<!-- low opacity and "font-size: 0.9em;" let the user distinguish history from the main message. but low opacity is hard to read, and high opacity is indistinguishable from black.
	the history needs to be clearly distinguishable so the user's eyes instantly see where the end is. a color change is better. blue and purple overlap with links, red sucks, yellow is too bright. orange/brown, green. -->
	<ul id=history_container style='white-space:pre-wrap; display: flex; list-style: circle; padding-left: 1em; margin: 0; color: DarkGreen;'></ul>

	<!-- options jumping around are really distracting, so they're kept fixed at the bottom or top. they can't be below the page bottom; that would cause a scrollbar. and hiding the scrollbar is bad. -->
	<div style='text-align:center; margin: 0.3em auto;'>Options:
		<a id=history_number_option class=ca tabindex=0 onmousedown=prompt_history_retention()>History retention</a>
		<a class=ca tabindex=0 onmousedown=flip_history_position()>Flip order</a><span class=screenreader>Reorder the main body, history, and options back-to-front.</span>
		<a id=keyboard_shortcuts_option class=ca tabindex=0 onmousedown=flip_keyboard_enabled()>Keyboard shortcuts</a><span class=screenreader>Screenreader users should disable this setting.</span>
		<span id=keyboard_rebinding_options>
		rebind keys:
		<a id=c0 class=l0 tabindex=0 onmousedown=changekeybind(0)><span class=screenreader>keybind 1 is</span></a>
		<a id=c1 class=l1 tabindex=0 onmousedown=changekeybind(1)><span class=screenreader>keybind 2 is</span></a>
		<a id=c2 class=l2 tabindex=0 onmousedown=changekeybind(2)><span class=screenreader>keybind 3 is</span></a>
		<a id=c3 class=l3 tabindex=0 onmousedown=changekeybind(3)><span class=screenreader>keybind 4 is</span></a>
		<a id=c4 class=l4 tabindex=0 onmousedown=changekeybind(4)><span class=screenreader>keybind 5 is</span></a>
		<a id=c5 class=l5 tabindex=0 onmousedown=changekeybind(5)><span class=screenreader>keybind 6 is</span></a>
		<a id=c6 class=l6 tabindex=0 onmousedown=changekeybind(6)><span class=screenreader>keybind 7 is</span></a>
		<a id=c7 class=l7 tabindex=0 onmousedown=changekeybind(7)><span class=screenreader>keybind 8 is</span></a>
		<a id=c8 class=l8 tabindex=0 onmousedown=changekeybind(8)><span class=screenreader>keybind neutral is</span></a>
		</span>
	</div>
</body>

<script type='text/javascript'>
//helper script for css manipulation
var new_stylesheet = document.createElement('style');
new_stylesheet.type = 'text/css';
document.head.appendChild(new_stylesheet);
var stylesheet = new_stylesheet.sheet;
function changecss(selector, property, value) {
	/* from stackoverflow. selectorText: e.g. '#myId', '.myClass', 'thead td'
	 * style: e.g. 'fontSize'
	 * value: the new value. if a string, such as when style = 'content', you might need nested quotes, like '\' text \''
	 */
	for (var i = 0; i < document.styleSheets.length; ++i) {
		rules = document.styleSheets[i].cssRules;
		for (var n in rules) {
			if (rules[n].selectorText == selector) {
				rules[n].style[property] = value;
				return;
			}
		}
	}
	//wasn't found, so insert a new rule
	try {stylesheet.insertRule(selector + ' {' + property + ':' + value + '}', stylesheet.cssRules.length);}
	catch (err) {alert("Stylesheet failed, couldn't add or find style!");}
}


//inverts the page order
var history_above = (localStorage.getItem('history above') === 'true');
(window.set_page_order = function() {
	if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > -1)
		history_above = 'true'; //IE11 workaround for poor flexbox support
	//otherwise, would require annoying workarounds seen in the css linked here: https://philipwalton.github.io/solved-by-flexbox/demos/sticky-footer/

	history_container.style['flex-direction'] = 'column' + (history_above ? '-reverse' : '');
	main_body.style['min-height'] = history_above ? '75vh' : '50vh'; //75vh preserves some of the previous scrollback to maintain context while keeping the new message at a constant position. when the history is below, it's not as useful. to have no height, use 'auto'.
	main_body.style.flex = history_above ? '1' : '0';
	history_container.style.flex = history_above ? '0' : '1';
	//note: if you use auto, then the options shouldn't flip when the history flips, and should instead stay on top permanently.
	flexboxflip.style['flex-direction'] = 'column' + (history_above ? '-reverse' : '');
	scrolltarget.style.display = history_above ? 'inline' : 'none';
	//vertical_layout_option.textContent = 'History position ' + (history_above ? 'above' : 'below');
})();

//alert user on thrown exceptions
window.onerror = function() {main_body.innerHTML += '<br>Error, press F12 to see JavaScript console';};

function flip_history_position() {
	history_above = !history_above;
	set_page_order();
	localStorage.setItem('history above', history_above);
}


//keyboard shortcut handling and rebinding. also, makes Enter key trigger onclick()
var keyboard_shortcuts_enabled = (localStorage.getItem('keyboard shortcuts enabled') === 'true');
var rebindingkey = false;
var rebindingkeynumber = 0;

function changekeybind(number) {
	document.getElementById('c' + rebindingkeynumber).style['font-weight'] = 'normal'; //if you click on different rebinds in succession, stop rebinding the first
	if ((rebindingkeynumber == number) && (rebindingkey == true))
	{
		rebindingkey = false; //if you click the same rebind twice, stop rebinding entirely
		return;
	}
	rebindingkey = true;
	rebindingkeynumber = number;
	document.getElementById('c' + rebindingkeynumber).style['font-weight'] = 'bold';
}
var keycoderaw = [113, 119, 101, 114, 97, 115, 100, 102, 103]; //qwerasdf g
for (var n in keycoderaw) {
	if (!(localStorage.getItem('keycode ' + n) === null))
		keycoderaw[n] = localStorage.getItem('keycode ' + n).charCodeAt();
}


//links are tabbable only if they aren't keybound
function keybound_links_nontabbable() {
	for (var n in keycoderaw) {
		var possible_link = document.getElementById('l' + n);
		if (possible_link !== null)
			possible_link.setAttribute('tabindex', keyboard_shortcuts_enabled ? '-1' : '0');
	}
}
//enable/disable keyboard shortcuts
(window.keyboard_enable_implement = function() {
	keyboard_shortcuts_option.textContent = 'Keyboard shortcuts: ' + (keyboard_shortcuts_enabled ? 'on' : 'off');
	for (var n in keycoderaw) {
		changecss('#l' + n + '::after', 'content', keyboard_shortcuts_enabled ? '\'' + String.fromCharCode(keycoderaw[n]) + '\'' : '\'\'');
		changecss('#l' + n + '::after', 'vertical-align', keyboard_shortcuts_enabled ? 'sub' : 'initial'); //subscripts cause line space distortion even when there's no text, so we have to reset it to initial when keybinds are disabled
		changecss('#l' + n + '::after', 'font-size', keyboard_shortcuts_enabled ? 'smaller' : 'initial');
		changecss('#c' + n + '::after', 'content', keyboard_shortcuts_enabled ? '\'[' + String.fromCharCode(keycoderaw[n]) + ']\'' : '\'\''); //change-keybind link in options
	}
	keyboard_rebinding_options.style.display = keyboard_shortcuts_enabled ? '' : 'none'; //visibility=hidden doesn't keep it in place. the rest of the options still shift around
	localStorage.setItem('keyboard shortcuts enabled', keyboard_shortcuts_enabled);
})();

function flip_keyboard_enabled() {
	keyboard_shortcuts_enabled = !keyboard_shortcuts_enabled;
	keyboard_enable_implement();
	keybound_links_nontabbable();
}


//history handler
var history_retention = 0; //better to be 0 by default. for example, in our intro document, images persist between screens, and duplicated images are confusing.
if (!(localStorage.getItem('history retention') === null))
	history_retention = parseInt(localStorage.getItem('history retention'));
(window.set_history_retention = function(number) {
	history_retention = number;
	history_number_option.textContent = 'History kept: ' + ((history_retention < 0) ? 'all' : history_retention);
	history_separator.style.display = history_retention ? '' : 'none';
})(history_retention); //call immediately, to write the options text
var history_id = 0;
var trailing_id = 0; //the history section contains each id in [trailing id, id).
function clear_old_history() {
	if (history_retention != -1) {
		for (; trailing_id < history_id - history_retention; ++trailing_id) {
			var obsolete_history = document.getElementById('history ' + trailing_id);
			obsolete_history.parentNode.removeChild(obsolete_history);
		}
	}
}

function prompt_history_retention() {
	var value = prompt('Enter number of history entries to keep. Blank for no limit.', (history_retention == -1) ? '' : history_retention);

	if (value != null) {
		var history_retention_new = parseInt(value);
		if (isNaN(history_retention_new) || (history_retention_new < 0)) history_retention_new = -1; //collapse to -1, instead of NaN, because of serialization
		set_history_retention(history_retention_new);
		localStorage.setItem('history retention', history_retention);
		clear_old_history();
	}
}


//set margins according to window width, and set line spacing in response to line length
//ratios change as font size changes. Open Sans looks ridiculously cramped at 16px and somewhat open at every other font size.
//font measurements in our library don't take zoom into account. measuring at 2x zoom gives all the same values as measuring at 1x zoom, though they should be different.
//desktop browsers stay at 1x zoom. but mobile browsers all have virtual zooms. we could get all our data for 1000px fonts, but for now, we'll just stay at 1em.
var x_height_ratio = 0.52; //ratio of x-height to font size. 0.52 is an estimate. if the estimate is used as a default, it's better to have the default be a little too open than a little too cramped
var average_width_ratio = 0.4; //ratio of letter width to font size, for the letters in the string 'Default i'. 0.4 is an estimate
function set_ratios(element) {
	var temporary_div = document.createElement('div');
	document.body.appendChild(temporary_div);
    temporary_div.style.height = '100ex';
    var ex_pixels = temporary_div.offsetHeight;
    temporary_div.style.height = '100em';
    var em_pixels = temporary_div.offsetHeight;
	x_height_ratio = ex_pixels / em_pixels;
	document.body.removeChild(temporary_div);

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    context.font = '1000px ' + window.getComputedStyle(element).fontFamily;
    average_width_ratio = context.measureText('Default i').width / 9000; //divide by 9 because 'Default i' has 9 characters. use px here, em causes trouble.
}
set_ratios(document.body);
//we can only get the font size once, at document load, because there's no cheap way to detect font size changes. but since the font library doesn't respect true pixel size anyway, this doesn't matter
//window.addEventListener('resize', set_ratios(document.body), false); //this leads to infinite recursion, and probably doesn't work in every browser. http://stackoverflow.com/a/2658045/

//the visual size of a font is very different from its font size. most of its size is determined by its x-height. thus, here we blend the x-height and the font size to produce a more accurate font measure.
var x_height_proportion = 0.7; //how much the x-height should matter in determining the effective font size. the remaining proportion is determined by the font size. try testing with Open Sans (x-height 0.535), Verdana (0.545), Garamond (0.384), and TNR (0.448) since they have the highest and lowest x-heights.
var effective_font_height_multiplier = x_height_ratio * x_height_proportion + 1 - x_height_proportion; //blends x-height and font size to find the "effective font height" as a ratio of the stated font size.
var effective_font_height_of_reference_05_x_height_font = 0.5 * x_height_proportion + 1 - x_height_proportion; //using the same formula, calculate the effective size of a "standard" calibration font with x-height = 0.5.
var expansion_ratio_relative_to_reference_font = effective_font_height_multiplier / effective_font_height_of_reference_05_x_height_font;
//font size is used here instead of the more accurate (ascent + descent), in order to respect the font designer's intentions.

//returns the true effective size of the font. scale: the reference font returns the nominal font size. fonts which are larger than their point size claims will return larger values.
//this captures variations in the specific font being used, where the nominal point size doesn't represent its true point size.
function effective_font_size() {
	var reported_font_size = parseFloat(window.getComputedStyle(main_body).fontSize); //font size from the main message, because that's the section designed for best reading.

	//the ratio used in conversion is (height + width / 2). we divide width by 2, because it doesn't seem to matter as much when determining the font size.
	var current_font_to_standard_font_ratio = (effective_font_height_multiplier + average_width_ratio / 2) / (effective_font_height_of_reference_05_x_height_font + 0.4 / 2);
	return reported_font_size * current_font_to_standard_font_ratio;
}

//all these default values are chosen by eyeballing, and without any peer-reviewed research.
var width_constant_margin_scaling = 70; //in em, for the standard font. when line length equals this value, the margin will be half of its maximum value.
var max_margin = 0.30; //this constant determines the margin's maximum proportion of the window width

var minimum_line_spacing = 1.25; //in em, for the standard font. this specifies the minimum line spacing for narrow passages.
var maximum_line_spacing = 1.47; //line spacing for very wide passages
var line_length_for_line_spacing_scaling = 30; //in em, for the standard font. when line length equals this value, the line spacing will be the average of the minimum and maximum.

var paragraph_margin_multiple = 0.35; //paragraph margin as a multiple of the line spacing
var section_margin_multiple = 1.0;

function rescale_line_spacing(element) {
	var line_length = element.clientWidth / effective_font_size();
	//clientWidth is better than scrollWidth, because a horizontal scrollbar can be created by a single word whose length is larger than the containing box.
	//if your box has a horizontal scrollbar by default, then scrollWidth might be more reasonable, but that is a horrible situation to design for. you don't want horizontal scrollbars.
	var scaled_line_length = Math.pow(line_length / line_length_for_line_spacing_scaling, 2);
	var new_line_height_ratio = (maximum_line_spacing * scaled_line_length + minimum_line_spacing)/(scaled_line_length + 1) * expansion_ratio_relative_to_reference_font;
	element.style.lineHeight = (new_line_height_ratio).toString();

	changecss('#' + element.id + ' p', 'margin-top', new_line_height_ratio * paragraph_margin_multiple + 'em');
	if (element === history_container)
		changecss('#' + element.id + ' > li', 'margin-bottom', new_line_height_ratio * section_margin_multiple + 'em');
}

function remargin_main(event){
	var relative_effective_font_size = effective_font_size();
	flexboxflip.style.marginLeft = relative_effective_font_size.toString() + 'px';
	flexboxflip.style.marginRight = relative_effective_font_size.toString() + 'px'; //do this before getting body's clientWidth, because this changes the body

	var available_width = document.body.clientWidth + 2 * relative_effective_font_size; //total width, including built-in margin. don't use window.innerWidth, pinch zooming will change that.
	var main_body_width = main_body.parentElement.clientWidth; //available space to stretch in. we use parentElement's width so that changing main_body's width doesn't change this number.
	var scaled_width = Math.pow(available_width / width_constant_margin_scaling / relative_effective_font_size, 2);
	var margin_scaling = scaled_width / (scaled_width + 1);
	var desired_margin = max_margin * margin_scaling * available_width - relative_effective_font_size;
	//note that flexboxflip's left margin is not being merged. that's why we calculate absolute units and subtract from there.

	if (desired_margin < relative_effective_font_size)
		desired_margin = 0; //clamp to edge if it's too small to effectively distinguish main text from history text, or if it's below zero (when the built-in margin is sufficient).
	var desired_margin_ratio = desired_margin / main_body_width;
	main_body.style.marginLeft = (100 * desired_margin_ratio).toString() + '%';
	main_body.style.marginRight = (100 * desired_margin_ratio).toString() + '%';

	rescale_line_spacing(history_container);
	rescale_line_spacing(main_body);

	//could use overall viewport width or screen width, not clientWidth. this also helps with side-by-side windows, or websites embedded in other websites. but multi-monitors have large sections that the user doesn't bother to look at. so viewport width/client width is fine, rather than screen width. note that viewport width includes the scrollbar, we don't want that. % doesn't include the scrollbar.
}
window.addEventListener('DOMContentLoaded', remargin_main);
window.addEventListener('resize', remargin_main);
</script>
</html>