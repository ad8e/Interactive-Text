<!doctype html>
<html lang="en-us">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge" /> <!-- solves IE compatibility problem: https://stackoverflow.com/a/35825985/ -->
<title>Interactive Text</title>
<style>
body {font-family: "Open Sans", sans-serif;}

/* bold-only, non-blue links are hard to distinguish and unconventional */
a:not([href]) {color: blue;}
a[onclick]:not([href]) {cursor: pointer;}
a[href] {text-decoration: none;}
a[href]:hover, a[onclick]:hover {text-decoration: underline;}

.disabled_link {text-decoration: line-through;}
.disabled_link:hover {text-decoration: none;}

/* surround with brackets. used to separate options */
.ca::after {content: "]";}
.ca::before {content: "[";}

/* bold links in history have an intuitive meaning. links surrounded with brackets have unclear meaning, overlapping with the keyboard shortcuts */
.chosen_link_in_history {font-weight: bold;}
/* links in history aren't clickable. the user has Pavlovian training to click on blue links, and is constantly surprised by nonclickable blue text. darkening fixes this problem */
a:not([href]).history {color: DarkBlue;}

/* hide text so that a screenreader can find it, but not visual users */
.screenreader {
	height: 1px;
	width: 1px;
	position: absolute;
	overflow: hidden;
	top: -10px;
}

p {margin-bottom: 0px}
li {margin-bottom: 0px}
</style>
<!-- lets the javascript know when the C++ module is safely loaded and ready to use -->
<script type='text/javascript'>
var emscripten_loaded = false;
</script>

<!-- helper script for css manipulation -->
<script type='text/javascript'>
var new_stylesheet = document.createElement('style');
new_stylesheet.type = "text/css";
document.head.appendChild(new_stylesheet);
var stylesheet = new_stylesheet.sheet;
function changecss(selector, property, value) {
	/* from stackoverflow. selectorText: e.g. '#myId', '.myClass', 'thead td'
	 * style: e.g. 'fontSize'
	 * value: the new value. if a string, such as when style = "content", you might need nested quotes, like "\" text \""
	 */
	for (var i = 0; i < document.styleSheets.length; ++i) {
		rules = document.styleSheets[i].cssRules;
		for (var n in rules) {
			if (rules[n].selectorText == selector) {
				rules[n].style[property] = value;
				return;
			}
		}
	}
	//wasn't found, so insert a new rule
	try {stylesheet.insertRule(selector + ' {' + property + ':' + value + '}', stylesheet.cssRules.length);}
	catch (err) {alert("Stylesheet failed, couldn't add or find style!");}
}
</script>

<!-- keyboard shortcut handling and rebinding. also, makes Enter key trigger onclick() -->
<script type='text/javascript'>
var keyboard_shortcuts_enabled = (localStorage.getItem("keyboard shortcuts enabled") === "true");
var rebindingkey = false;
var rebindingkeynumber = 0;

function changekeybind(number) {
	document.getElementById('c' + rebindingkeynumber).style['font-weight'] = 'normal'; //if you click on different rebinds in succession, stop rebinding the first
	if ((rebindingkeynumber == number) && (rebindingkey == true))
	{
		rebindingkey = false; //if you click the same rebind twice, stop rebinding entirely
		return;
	}
	rebindingkey = true;
	rebindingkeynumber = number;
	document.getElementById('c' + rebindingkeynumber).style['font-weight'] = 'bold';
}
var keycoderaw = [113, 119, 101, 114, 97, 115, 100, 102, 103]; //qwerasdf g
for (var n in keycoderaw) {
	if (!(localStorage.getItem("keycode " + n) === null))
		keycoderaw[n] = localStorage.getItem("keycode " + n).charCodeAt();
}
document.onkeypress = function(e) {
	if (e.repeat) return;
	if (rebindingkey)
	{
		//note: e.which is required, instead of e.charCode, because charCode doesn't support Enter
		switch (e.which) {
		case 0:
			alert("Only glyphs are supported, like letters, numbers, and punctuation. That excludes keys like arrows and Ctrl. This is because of javascript problems.");
			return;
		case 13:
			alert("Enter is a disallowed keybind, because you need Enter to select links when tabbing. Plus, Enter causes trouble with javascript's fromCharCode().");
			return;
		case 32:
			alert("Space is not recommended because it is invisible and will scroll your page down.");
			return;
		}
		rebindingkey = false;
		//for (var i in keycoderaw) if (keycoderaw[i] == e.which) return; //this is annoying for intermediate state changes
		keycoderaw[rebindingkeynumber] = e.which;
		localStorage.setItem("keycode " + rebindingkeynumber, String.fromCharCode(e.which));
		changecss("#l" + rebindingkeynumber + "::after", "content", keyboard_shortcuts_enabled ? "\"" + String.fromCharCode(e.which) + "\"" : "\"\""); //we still need to check keyboard_shortcuts_enabled because user might try to rebind a key and then disable shortcuts
		changecss("#c" + rebindingkeynumber + "::after", "content", keyboard_shortcuts_enabled ? "\"[" + String.fromCharCode(e.which) + "]\"" : "\"\"");
		document.getElementById('c' + rebindingkeynumber).style['font-weight'] = 'normal';
		return;
	}
	for (var n in keycoderaw)
	{
		if ((e.which == keycoderaw[n]) && emscripten_loaded && keyboard_shortcuts_enabled)
		{
			Module._i(-n - 1);
			return;
		}
	}
	if (e.which == 13) //trigger onclick() with enter key. 13 = enter key.
	{
		if (typeof document.activeElement.onclick == 'function') document.activeElement.onclick();
		return;
	}
};
</script>

<div class="emscripten" id="status" style="text-align:center">Downloading...</div>

<!-- inverse flexbox moves the options tab order to the end of the page, so that the first tab chooses a game link, instead of an options link -->
<div id="flexboxflip" style="display: flex; display: -webkit-flex; color:#222222;">
	<!-- role="status" is for ARIA accessibility. role="main" by itself is not re-read properly. w3c validator says one role only. note that IE doesn't support the main tag. -->
	<div id='m' role="status" style="margin:0.5em; white-space:pre-wrap;" aria-live="polite"></div>

	<hr style="margin:0.5em">
	<!-- visual testing shows that this horizontal bar is critical to helping the user find the beginning of the passage. if it's not visible, the user worries and scrolls up to make sure he didn't miss anything. -->
	<!-- we add a scrolltarget which is slightly higher than the bar, because scrollIntoView(bar) makes the bar indistinguishable from the top of the page. -->
	<!-- if the main message is too long, its top will stick to the top of the page, and the bottom of the message will take priority over the scrollback. -->
	<div id='scrolltarget' style="padding-bottom:0.3em;"></div>

	<!-- low opacity and 90% font size let the user distinguish history from the main message. but low opacity is hard to read, and high opacity is indistinguishable from black.
	the history needs to be clearly distinguishable so the user's eyes instantly see where the end is. a color change is better. blue and purple overlap with links, red sucks, yellow is too bright. orange/brown, green. -->
	<ul id='H' style="font-size: 0.9em; white-space:pre-wrap; display: flex; display: -webkit-flex; list-style: circle; padding-left: 1em; margin: 0; color: DarkGreen;"></ul>
	<div id="options_section" style="text-align:center">Options:
		<a id="ch" class="ca" tabindex="0" onclick="prompt_history_retention();">History retention</a>
		<a id="cp" class="ca" tabindex="0" onclick="flip_history_position();">History on bottom</a>
		<a id="ck" class="ca" tabindex="0" onclick="flip_keyboard_enabled();">Keyboard shortcuts</a>
		<span id="keyboard_rebinding_options">
		rebind keys:
		<a id="c0" class="l0" tabindex="0" onclick="changekeybind(0);"><span class="screenreader">1 is</span></a>
		<a id="c1" class="l1" tabindex="0" onclick="changekeybind(1);"><span class="screenreader">2 is</span></a>
		<a id="c2" class="l2" tabindex="0" onclick="changekeybind(2);"><span class="screenreader">3 is</span></a>
		<a id="c3" class="l3" tabindex="0" onclick="changekeybind(3);"><span class="screenreader">4 is</span></a>
		<a id="c4" class="l4" tabindex="0" onclick="changekeybind(4);"><span class="screenreader">5 is</span></a>
		<a id="c5" class="l5" tabindex="0" onclick="changekeybind(5);"><span class="screenreader">6 is</span></a>
		<a id="c6" class="l6" tabindex="0" onclick="changekeybind(6);"><span class="screenreader">7 is</span></a>
		<a id="c7" class="l7" tabindex="0" onclick="changekeybind(7);"><span class="screenreader">8 is</span></a>
		<a id="c8" class="l8" tabindex="0" onclick="changekeybind(8);"><span class="screenreader">neutral is</span></a>
		</span>
	</div>
</div>
<!-- history above -->
<script type='text/javascript'>
//true only if localstorage says it's true
var history_above = (localStorage.getItem("history above") === "true");
function set_history_position() {
	changecss("#H", "flex-direction", "column" + (history_above ? "-reverse" : ""));
	changecss("#m", "min-height", history_above ? "75vh" : "50vh"); //75vh preserves some of the previous scrollback to maintain context while keeping the new message at a constant position. when the history is below, it's not as useful. to have no height, use "auto".
	//note: if you use auto, then the options shouldn't flip when the history flips, and should instead stay on top permanently.
	changecss("#flexboxflip", "flex-direction", "column" + (history_above ? "-reverse" : ""));
	changecss("#scrolltarget", "display", (history_above ? "inline" : "none"));
	document.getElementById("cp").textContent = "History position " + (history_above ? "above" : "below");
}
set_history_position();
function flip_history_position() {
	history_above = !history_above;
	set_history_position();
	localStorage.setItem("history above", history_above);
}
</script>

<!-- emscripten's javascript -->
<script type='text/javascript'>
var statusElement = document.getElementById('status');
var Module = {
	print: function(text) {
		if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
		console.log(text);
	},
	printErr: function(text) {
		if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
		console.error(text);
	},
	setStatus: function(text) {
		statusElement.textContent = text;
	},
	totalDependencies: 0,
	monitorRunDependencies: function(left) {
		this.totalDependencies = Math.max(this.totalDependencies, left);
		Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies - left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
	}
};
window.onerror = function() {
	Module.setStatus('Exception thrown, see JavaScript console');
	Module.setStatus = function(text) {
		if (text) Module.printErr('[post-exception status] ' + text);
	};
};
</script>

<!-- enable/disable keyboard shortcuts -->
<script type='text/javascript'>
function keyboard_enable_implement() {
	document.getElementById("ck").textContent = "Keyboard shortcuts " + (keyboard_shortcuts_enabled ? "enabled" : "disabled");
	for (var n in keycoderaw) {
		changecss("#l" + n + "::after", "content", keyboard_shortcuts_enabled ? "\"" + String.fromCharCode(keycoderaw[n]) + "\"" : "\"\"");
		changecss("#l" + n + "::after", "vertical-align", keyboard_shortcuts_enabled ? "sub" : "initial"); //subscripts cause line space distortion even when there's no text, so we have to reset it to initial when keybinds are disabled
		changecss("#l" + n + "::after", "font-size", keyboard_shortcuts_enabled ? "smaller" : "initial");
		changecss("#c" + n + "::after", "content", keyboard_shortcuts_enabled ? "\"[" + String.fromCharCode(keycoderaw[n]) + "]\"" : "\"\""); //change-keybind link in options
	}
	document.getElementById("keyboard_rebinding_options").style.display = keyboard_shortcuts_enabled ? "" : "none"; //visibility=hidden doesn't keep it in place. the rest of the options still shift around
	localStorage.setItem("keyboard shortcuts enabled", keyboard_shortcuts_enabled);
}
keyboard_enable_implement();

function flip_keyboard_enabled() {
	keyboard_shortcuts_enabled = !keyboard_shortcuts_enabled;
	keyboard_enable_implement();
	enable_disable_tabbing_for_keybound_links(); //links are tabbable only if they aren't keybound
}

function enable_disable_tabbing_for_keybound_links() {
	for (var n in keycoderaw) {
		var possible_link = document.getElementById('l' + n);
		if (possible_link !== null) {
			possible_link.setAttribute('tabindex', keyboard_shortcuts_enabled ? '-1' : '0');
		}
	}
}
</script>

<!-- history handler -->
<script type='text/javascript'>
var history_retention = 1;
if (!(localStorage.getItem("history retention") === null))
	history_retention = parseInt(localStorage.getItem("history retention"));
function set_history_retention(number) {
	history_retention = number;
	document.getElementById("ch").textContent = "History kept: " + ((history_retention < 0) ? "all" : history_retention);
}
set_history_retention(history_retention); //write the options text
var id = 0;
var trailing_id = 0; //the history section contains each id in [trailing id, id).
function clear_old_history() {
	if (history_retention != -1) {
		for (; trailing_id < id - history_retention; ++trailing_id) {
			var obsolete_history = document.getElementById("history " + trailing_id);
			obsolete_history.parentNode.removeChild(obsolete_history);
		}
	}
}
var history_container = document.getElementById('H');
function insert_history(text) {
	if (history_retention != 0) {
		var new_history = document.createElement('li');
		new_history.id = "history " + (id++);
		new_history.innerHTML = Module.Pointer_stringify(text);
		history_container.insertBefore(new_history, history_container.firstChild);
	}
	clear_old_history();
}
function prompt_history_retention() {
	var value = prompt("Enter number of history entries to keep. Blank for no limit.", (history_retention == -1) ? "" : history_retention);

	if (value != null) {
		var history_retention_new = parseInt(value);
		if (isNaN(history_retention_new) || (history_retention_new < 0)) history_retention_new = -1; //collapse to -1, instead of NaN, because of serialization
		set_history_retention(history_retention_new);
		localStorage.setItem("history retention", history_retention);
		clear_old_history();
	}
}
</script>

<!-- new message handler -->
<script type='text/javascript'>
var main_body = document.getElementById('m');
var scrolltarget = document.getElementById('scrolltarget');
function change_message(text) {
	main_body.innerHTML = Module.Pointer_stringify(text);
	enable_disable_tabbing_for_keybound_links();
	if (history_above) scrolltarget.scrollIntoView(true);
	else window.scrollTo(0, 0);
}
</script>
{{{ SCRIPT }}}

<!-- set margins according to window width, and set line spacing in response to line length -->
<script type='text/javascript'>
//ratios change as font size changes. Open Sans looks ridiculously cramped at 16px and somewhat open at every other font size.
//font measurements in our library don't take zoom into account. measuring at 2x zoom gives all the same values as measuring at 1x zoom, though they should be different.
//desktop browsers stay at 1x zoom. but mobile browsers all have virtual zooms. we could get all our data for 1000px fonts, but for now, we'll just stay at 1em.
var x_height_ratio = 0.52; //ratio of x-height to font size. 0.52 is an estimate. if the estimate is used as a default, it's better to have the default be a little too open than a little too cramped
var average_width_ratio = 0.4; //ratio of letter width to font size, for the letters in the string "Default i". 0.4 is an estimate
function set_ratios(element) {
	var temporary_div = document.createElement("div");
	document.body.appendChild(temporary_div);
    temporary_div.style.height = '100ex';
    var ex_pixels = temporary_div.offsetHeight;
    temporary_div.style.height = '100em';
    var em_pixels = temporary_div.offsetHeight;
	x_height_ratio = ex_pixels / em_pixels;
	document.body.removeChild(temporary_div);

    var canvas = document.createElement("canvas");
    var context = canvas.getContext("2d");
    context.font = '1000px ' + window.getComputedStyle(element).fontFamily;
    average_width_ratio = context.measureText("Default i").width / 9000; //divide by 9 because "Default i" has 9 characters. use px here, em causes trouble.
}
set_ratios(document.body);
//we can only get the font size once, at document load, because there's no cheap way to detect font size changes. but since the font library doesn't respect true pixel size anyway, this doesn't matter
//window.addEventListener("resize", set_ratios(document.body), false); //this leads to infinite recursion, and probably doesn't work in every browser. http://stackoverflow.com/a/2658045/

//the visual size of a font is very different from its font size. most of its size is determined by its x-height. thus, here we blend the x-height and the font size to produce a more accurate font measure.
var x_height_proportion = 0.7; //how much the x-height should matter in determining the effective font size. the remaining proportion is determined by the font size. try testing with Open Sans (x-height 0.535), Verdana (0.545), Garamond (0.384), and TNR (0.448) since they have the highest and lowest x-heights.
var effective_font_height_multiplier = x_height_ratio * x_height_proportion + 1 - x_height_proportion; //blends x-height and font size to find the "effective font height" as a ratio of the stated font size.
var effective_font_height_of_reference_05_x_height_font =  0.5 * x_height_proportion + 1 - x_height_proportion; //using the same formula, calculate the effective size of a "standard" calibration font with x-height = 0.5.
var expansion_ratio_relative_to_reference_font = effective_font_height_multiplier / effective_font_height_of_reference_05_x_height_font;
//font size is used here instead of the more accurate (ascent + descent), in order to respect the font designer's intentions.

//standard font 1em in the current font size, converted to px.
//the ratio used in conversion is (height + width / 2). we divide width by 2, because it doesn't seem to matter as much when determining the font size.
//we get the font size from the main message, because that's the section designed for best reading.
function fixed_arc_relative_to_standard_font() {
	var px_of_fixed_arc = parseFloat(window.getComputedStyle(document.getElementById('m')).fontSize) * (effective_font_height_multiplier + average_width_ratio / 2);
	return px_of_fixed_arc / (effective_font_height_of_reference_05_x_height_font + 0.4 / 2);
}

//all these default values are chosen by eyeballing, and without any peer-reviewed research.
var width_constant_margin_scaling = 70; //in em, for the standard font. when line length equals this value, the margin will be half of its maximum value.
var max_margin = 0.30; //this constant determines the margin's maximum proportion of the window width

var minimum_line_spacing = 1.25; //in em, for the standard font. this specifies the minimum line spacing for narrow passages.
var maximum_line_spacing = 1.47; //line spacing for very wide passages
var line_length_for_line_spacing_scaling = 30; //in em, for the standard font. when line length equals this value, the line spacing will be the average of the minimum and maximum.

var paragraph_margin_multiple = 0.35; //paragraph margin as a multiple of the line spacing
var section_margin_multiple = 1.0;

function rescale_line_spacing(element) {
	var line_length = element.clientWidth / fixed_arc_relative_to_standard_font();
	//clientWidth is better than scrollWidth, because a horizontal scrollbar can be created by a single word whose length is larger than the containing box.
	//if your box has a horizontal scrollbar by default, then scrollWidth might be more reasonable, but that is a horrible situation to design for. you don't want horizontal scrollbars.
	var scaled_line_length = Math.pow(line_length / line_length_for_line_spacing_scaling, 2);
	var new_line_height_ratio = (maximum_line_spacing * scaled_line_length + minimum_line_spacing)/(scaled_line_length + 1) * expansion_ratio_relative_to_reference_font;
	element.style.lineHeight = (new_line_height_ratio).toString();

	changecss("#" + element.id + " p", "margin-top", new_line_height_ratio * paragraph_margin_multiple + "em");
	if (element === document.getElementById("H"))
		changecss("#" + element.id + " > li", "margin-top", new_line_height_ratio * section_margin_multiple + "em");
}

function remargin_main(event){
	var relative_effective_font_size = fixed_arc_relative_to_standard_font();

	var available_width = main_body.parentElement.clientWidth;
	var scaled_width = Math.pow(available_width / width_constant_margin_scaling / relative_effective_font_size, 2);
	var margin_scaling = scaled_width / (scaled_width + 1);
	if (margin_scaling * available_width * max_margin < relative_effective_font_size)
		margin_scaling = 0; //clamp to edge if it's too small to effectively distinguish main text from history text.
	main_body.style.marginLeft = (100 * max_margin * margin_scaling).toString() + "%";
	main_body.style.marginRight = (100 * max_margin * margin_scaling).toString() + "%";

	rescale_line_spacing(document.getElementById("H"));
	rescale_line_spacing(main_body);
}
window.addEventListener('DOMContentLoaded', remargin_main);
window.addEventListener('resize', remargin_main);
</script>
</html>